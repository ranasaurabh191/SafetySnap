import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { detectionAPI } from '@/services/api';
import { Card } from '@/components/common/Card';
import { Badge } from '@/components/common/Badge';
import { Button } from '@/components/common/Button';
import { LoadingSpinner } from '@/components/common/LoadingSpinner';
import { 
  ArrowLeft, 
  Users, 
  Clock, 
  MapPin, 
  Calendar,
  User,
  Shield,
  AlertTriangle,
  CheckCircle,
  XCircle
} from 'lucide-react';


export const DetectionDetail = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';


  const { data: detection, isLoading, error } = useQuery({
    queryKey: ['detection', id],
    queryFn: () => detectionAPI.getById(id!),
    enabled: !!id,
  });


  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-96">
        <LoadingSpinner size="lg" />
      </div>
    );
  }


  if (error || !detection) {
    return (
      <div className="space-y-6">
        <Button onClick={() => navigate('/detections')} variant="secondary">
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to Detections
        </Button>
        <Card padding="lg">
          <div className="text-center py-12">
            <AlertTriangle className="h-12 w-12 text-red-500 mx-auto mb-4" />
            <h2 className="text-xl font-bold text-gray-900 dark:text-white mb-2">Detection Not Found</h2>
            <p className="text-gray-600 dark:text-gray-400">
              The detection you're looking for doesn't exist or has been deleted.
            </p>
          </div>
        </Card>
      </div>
    );
  }


  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <Button onClick={() => navigate('/detections')} variant="secondary">
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back
        </Button>
        <Badge
          variant={
            detection.compliance_status === 'compliant'
              ? 'success'
              : detection.compliance_status === 'partial'
              ? 'warning'
              : 'danger'
          }
          size="lg"
        >
          {detection.compliance_status?.replace('_', ' ')}
        </Badge>
      </div>


      {/* Detection Images */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Original Image */}
        <Card padding="lg">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
            Original Image
          </h3>
          {detection.original_image ? (
            <img
              src={`${API_BASE_URL}${detection.original_image}`}
              alt="Original"
              className="w-full rounded-lg border border-gray-200 dark:border-gray-700"
              onError={(e) => {
                e.currentTarget.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300"><rect fill="%23ddd" width="400" height="300"/><text x="50%" y="50%" text-anchor="middle" fill="%23999">Image not available</text></svg>';
              }}
            />
          ) : (
            <div className="w-full h-64 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center">
              <p className="text-gray-500 dark:text-gray-400">No image available</p>
            </div>
          )}
        </Card>


        {/* Annotated Result Image */}
        <Card padding="lg">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4 flex items-center gap-2">
            Detection Results
            <Badge variant="info" size="sm">With Bounding Boxes</Badge>
          </h3>
          {detection.annotated_image ? (
            <div>
              <img
                src={`${API_BASE_URL}${detection.annotated_image}`}
                alt="Annotated Results"
                className="w-full rounded-lg border-2 border-blue-500 dark:border-blue-400"
                onError={(e) => {
                  e.currentTarget.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="300"><rect fill="%23ddd" width="400" height="300"/><text x="50%" y="50%" text-anchor="middle" fill="%23999">Annotated image not available</text></svg>';
                }}
              />
              <div className="mt-3 flex items-center justify-between text-xs">
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 bg-green-500 rounded"></div>
                  <span className="text-gray-600 dark:text-gray-400">Compliant</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 bg-red-500 rounded"></div>
                  <span className="text-gray-600 dark:text-gray-400">Non-Compliant</span>
                </div>
              </div>
            </div>
          ) : (
            <div className="w-full h-64 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center">
              <div className="text-center">
                <Shield className="h-12 w-12 text-gray-400 mx-auto mb-2" />
                <p className="text-gray-500 dark:text-gray-400">Processing annotated image...</p>
              </div>
            </div>
          )}
        </Card>
      </div>


      {/* Detection Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <Card padding="lg">
          <div className="flex items-center gap-3">
            <Users className="h-8 w-8 text-blue-600 dark:text-blue-400" />
            <div>
              <p className="text-sm text-gray-600 dark:text-gray-400">Total Persons</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">
                {detection.total_persons_detected}
              </p>
            </div>
          </div>
        </Card>


        <Card padding="lg">
          <div className="flex items-center gap-3">
            <CheckCircle className="h-8 w-8 text-green-600 dark:text-green-400" />
            <div>
              <p className="text-sm text-gray-600 dark:text-gray-400">Compliant</p>
              <p className="text-2xl font-bold text-green-600 dark:text-green-400">
                {detection.compliant_persons}
              </p>
            </div>
          </div>
        </Card>


        <Card padding="lg">
          <div className="flex items-center gap-3">
            <XCircle className="h-8 w-8 text-red-600 dark:text-red-400" />
            <div>
              <p className="text-sm text-gray-600 dark:text-gray-400">Non-Compliant</p>
              <p className="text-2xl font-bold text-red-600 dark:text-red-400">
                {detection.non_compliant_persons}
              </p>
            </div>
          </div>
        </Card>


        <Card padding="lg">
          <div className="flex items-center gap-3">
            <Clock className="h-8 w-8 text-gray-600 dark:text-gray-400" />
            <div>
              <p className="text-sm text-gray-600 dark:text-gray-400">Processing Time</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">
                {detection.processing_time?.toFixed(2)}s
              </p>
            </div>
          </div>
        </Card>
      </div>


      {/* Detection Metadata */}
      <Card padding="lg">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">Detection Information</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
          <div className="flex items-center gap-2">
            <Calendar className="h-4 w-4 text-gray-400" />
            <span className="text-gray-600 dark:text-gray-400">Detected:</span>
            <span className="text-gray-900 dark:text-white font-medium">
              {new Date(detection.created_at).toLocaleString()}
            </span>
          </div>
          {detection.site_name && (
            <div className="flex items-center gap-2">
              <MapPin className="h-4 w-4 text-gray-400" />
              <span className="text-gray-600 dark:text-gray-400">Site:</span>
              <span className="text-gray-900 dark:text-white font-medium">{detection.site_name}</span>
            </div>
          )}
          <div className="flex items-center gap-2">
            <Shield className="h-4 w-4 text-gray-400" />
            <span className="text-gray-600 dark:text-gray-400">Policy:</span>
            <span className="text-gray-900 dark:text-white font-medium">
              {detection.policy_name || 'Default Policy'}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <User className="h-4 w-4 text-gray-400" />
            <span className="text-gray-600 dark:text-gray-400">Confidence:</span>
            <span className="text-gray-900 dark:text-white font-medium">
              {(detection.confidence_score * 100).toFixed(1)}%
            </span>
          </div>
        </div>
        {detection.notes && (
          <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
            <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">Notes:</p>
            <p className="text-gray-900 dark:text-white">{detection.notes}</p>
          </div>
        )}
      </Card>


      {/* Individual Person Analysis */}
      <Card padding="lg">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4 flex items-center gap-2">
          <Users className="h-6 w-6" />
          Individual Analysis ({detection.person_detections?.length || 0}{' '}
          {detection.person_detections?.length === 1 ? 'Person' : 'Persons'})
        </h2>


        {!detection.person_detections || detection.person_detections.length === 0 ? (
          <div className="text-center py-8 text-gray-500 dark:text-gray-400">
            <Users className="h-12 w-12 mx-auto mb-3 opacity-50" />
            <p>No person detections found</p>
            <p className="text-sm mt-1">This may be due to processing issues or no persons in the image</p>
          </div>
        ) : (
          <div className="space-y-4">
            {detection.person_detections.map((person) => (
              <div
                key={person.id}
                className={`p-4 rounded-lg border-2 ${
                  person.is_compliant
                    ? 'border-green-500 dark:border-green-600 bg-green-50 dark:bg-green-900/20'
                    : 'border-red-500 dark:border-red-600 bg-red-50 dark:bg-red-900/20'
                }`}
              >
                <div className="flex items-center justify-between mb-3">
                  <h3 className="font-semibold text-gray-900 dark:text-white flex items-center gap-2">
                    <User className="h-5 w-5" />
                    Person #{person.person_id}
                  </h3>
                  <Badge variant={person.is_compliant ? 'success' : 'danger'}>
                    {person.is_compliant ? 'Compliant' : 'Non-Compliant'}
                  </Badge>
                </div>


                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                  {[
                    { name: 'Helmet', detected: person.helmet_detected, confidence: person.helmet_confidence },
                    { name: 'Safety Vest', detected: person.vest_detected, confidence: person.vest_confidence },
                    
                    { name: 'Mask', detected: person.mask_detected, confidence: person.mask_confidence },
                  ].map((item) => (
                    <div
                      key={item.name}
                      className={`p-2 rounded text-center text-sm ${
                        item.detected
                          ? 'bg-green-100 dark:bg-green-800/30 text-green-800 dark:text-green-300'
                          : 'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400'
                      }`}
                    >
                      <div className="font-medium">{item.name}</div>
                      <div className="text-xs mt-1">
                        {item.detected ? `✓ ${(item.confidence * 100).toFixed(0)}%` : '✗ Not detected'}
                      </div>
                    </div>
                  ))}
                </div>


                {!person.is_compliant && person.missing_ppe && person.missing_ppe.length > 0 && (
                  <div className="mt-3 p-3 bg-red-100 dark:bg-red-900/30 rounded border border-red-300 dark:border-red-700">
                    <p className="text-sm font-medium text-red-800 dark:text-red-300">
                      Missing PPE:{' '}
                      {person.missing_ppe
                        .map((item) =>
                          item
                            .replace('_', ' ')
                            .replace(/\b\w/g, (l) => l.toUpperCase())
                        )
                        .join(', ')}
                    </p>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </Card>


      {/* Violations */}
      {detection.violations && detection.violations.length > 0 && (
        <Card padding="lg">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4 flex items-center gap-2">
            <AlertTriangle className="h-6 w-6 text-red-600 dark:text-red-400" />
            Violations ({detection.violations.length})
          </h2>
          <div className="space-y-3">
            {detection.violations.map((violation) => (
              <div
                key={violation.id}
                className="p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg"
              >
                <div className="flex items-start justify-between mb-2">
                  <h3 className="font-semibold text-red-900 dark:text-red-300">
                    {violation.violation_type}
                  </h3>
                  <Badge
                    variant={
                      violation.severity === 'critical'
                        ? 'danger'
                        : violation.severity === 'high'
                        ? 'warning'
                        : 'default'
                    }
                    size="sm"
                  >
                    {violation.severity}
                  </Badge>
                </div>
                <p className="text-sm text-gray-700 dark:text-gray-300 mb-2">
                  {violation.description}
                </p>
                {violation.recommendation && (
                  <p className="text-sm text-gray-600 dark:text-gray-400 italic">
                    Recommendation: {violation.recommendation}
                  </p>
                )}
              </div>
            ))}
          </div>
        </Card>
      )}
    </div>
  );
};


import { useQuery } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';
import { 
  FileSearch, 
  CheckCircle, 
  XCircle, 
  Clock,
  Eye,
  Calendar
} from 'lucide-react';
import { Card } from '@/components/common/Card';
import { Button } from '@/components/common/Button';
import axios from 'axios';


const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';


interface Detection {
  id: string;
  image: string;
  annotated_image: string;
  detected_at: string;
  num_persons: number;
  num_violations: number;
  confidence: number;
  processing_time: number;
}


const formatDate = (dateString: string) => {
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return 'Date unavailable';
    return date.toLocaleString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
  } catch {
    return 'Date unavailable';
  }
};


export const Detections = () => {
  const navigate = useNavigate();


  const { data: detections, isLoading } = useQuery<Detection[]>({
    queryKey: ['detections'],
    queryFn: async () => {
      const token = localStorage.getItem('token');
      const response = await axios.get(`${API_BASE_URL}/api/ppe/detections/`, {
        headers: { Authorization: `Token ${token}` }
      });
      return response.data;
    }
  });


  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }


  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Detection History</h1>
        <p className="text-gray-600 dark:text-gray-400 mt-1">
          View all PPE detection results
        </p>
      </div>


      {detections && detections.length === 0 ? (
        <Card padding="lg">
          <div className="text-center py-12">
            <FileSearch className="h-16 w-16 text-gray-400 mx-auto mb-4" />
            <h3 className="text-lg font-bold text-gray-900 dark:text-white mb-2">
              No detections yet
            </h3>
            <p className="text-gray-600 dark:text-gray-400 mb-6">
              Upload your first image to start detecting PPE
            </p>
            <Button onClick={() => navigate('/upload')}>
              Upload Image
            </Button>
          </div>
        </Card>
      ) : (
        <div className="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
          {detections?.map((detection) => {
            const isCompliant = detection.num_violations === 0;


            return (
              <Card key={detection.id} padding="none" className="overflow-hidden hover:shadow-lg transition-shadow cursor-pointer" onClick={() => navigate(`/detections/${detection.id}`)}>
                {/* Image */}
                <div className="relative aspect-video">
                  <img
                    src={`${API_BASE_URL}${detection.annotated_image}`}
                    alt="Detection"
                    className="w-full h-full object-cover"
                  />
                  <div className="absolute top-3 right-3">
                    <div
                      className={`px-3 py-1 rounded-full text-sm font-bold flex items-center gap-1 ${
                        isCompliant
                          ? 'bg-green-600 text-white'
                          : 'bg-red-600 text-white'
                      }`}
                    >
                      {isCompliant ? (
                        <>
                          <CheckCircle className="h-4 w-4" />
                          SAFE
                        </>
                      ) : (
                        <>
                          <XCircle className="h-4 w-4" />
                          UNSAFE
                        </>
                      )}
                    </div>
                  </div>
                </div>


                {/* Details */}
                <div className="p-4 space-y-3">
                  {/* Stats */}
                  <div className="grid grid-cols-3 gap-2">
                    <div className="text-center p-2 bg-blue-50 dark:bg-blue-900/20 rounded">
                      <div className="text-lg font-bold text-blue-600 dark:text-blue-400">
                        {detection.num_persons}
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Workers</div>
                    </div>
                    <div className="text-center p-2 bg-red-50 dark:bg-red-900/20 rounded">
                      <div className="text-lg font-bold text-red-600 dark:text-red-400">
                        {detection.num_violations}
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Violations</div>
                    </div>
                    <div className="text-center p-2 bg-green-50 dark:bg-green-900/20 rounded">
                      <div className="text-lg font-bold text-green-600 dark:text-green-400">
                        {(detection.confidence * 100).toFixed(0)}%
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Confidence</div>
                    </div>
                  </div>


                  {/* Metadata */}
                  <div className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
                    <div className="flex items-center gap-2">
                      <Calendar className="h-4 w-4" />
                      <span>{formatDate(detection.detected_at)}</span>
                    </div>
                    <div className="flex items-center gap-2">
                      <Clock className="h-4 w-4" />
                      <span>Processed in {detection.processing_time}s</span>
                    </div>
                  </div>


                  <Button
                    variant="secondary"
                    className="w-full"
                    onClick={(e) => {
                      e.stopPropagation();
                      navigate(`/detections/${detection.id}`);
                    }}
                  >
                    <Eye className="h-4 w-4 mr-2" />
                    View Details
                  </Button>
                </div>
              </Card>
            );
          })}
        </div>
      )}
    </div>
  );
};



import { Detection } from '@/types';
import { Card } from '@/components/common/Card';
import { Badge } from '@/components/common/Badge';
import { 
  Users, Clock, CheckCircle, XCircle, AlertTriangle, 
  Download, Share2, RotateCcw 
} from 'lucide-react';
import { Button } from '@/components/common/Button';
import { formatDuration, getPPELabel, getPPEIcon } from '@/utils/helpers';
import { motion } from 'framer-motion';


interface DetectionResultProps {
  detection: Detection;
  onReanalyze?: () => void;
}



export const DetectionResult: React.FC<DetectionResultProps> = ({ detection, onReanalyze }) => {
  const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';


  const getComplianceVariant = (status: string) => {
    switch (status) {
      case 'compliant':
        return 'success';
      case 'partial':
        return 'warning';
      case 'non_compliant':
        return 'danger';
      default:
        return 'default';
    }
  };


  const handleDownload = () => {
    if (detection.annotated_image) {
      const link = document.createElement('a');
      link.href = `${API_BASE_URL}${detection.annotated_image}`;
      link.download = `detection_${detection.id}.jpg`;
      link.click();
    }
  };


  return (
    <div className="space-y-6">
      {/* Header Stats */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <Card padding="md" className="text-center">
          <Users className="h-8 w-8 mx-auto text-blue-600 mb-2" />
          <div className="text-2xl font-bold text-gray-900">{detection.total_persons_detected}</div>
          <div className="text-sm text-gray-500">Persons Detected</div>
        </Card>


        <Card padding="md" className="text-center">
          <CheckCircle className="h-8 w-8 mx-auto text-green-600 mb-2" />
          <div className="text-2xl font-bold text-green-600">{detection.compliant_persons}</div>
          <div className="text-sm text-gray-500">Compliant</div>
        </Card>


        <Card padding="md" className="text-center">
          <XCircle className="h-8 w-8 mx-auto text-red-600 mb-2" />
          <div className="text-2xl font-bold text-red-600">{detection.non_compliant_persons}</div>
          <div className="text-sm text-gray-500">Non-Compliant</div>
        </Card>


        <Card padding="md" className="text-center">
          <Clock className="h-8 w-8 mx-auto text-gray-600 mb-2" />
          <div className="text-2xl font-bold text-gray-900">{formatDuration(detection.processing_time)}</div>
          <div className="text-sm text-gray-500">Processing Time</div>
        </Card>
      </div>


      {/* Annotated Image */}
      {detection.annotated_image && (
        <Card padding="none">
          <div className="relative">
            <img
              src={`${API_BASE_URL}${detection.annotated_image}`}
              alt="Detection Result"
              className="w-full h-auto rounded-lg"
            />
            <div className="absolute top-4 right-4 flex gap-2">
              <Button
                size="sm"
                variant="secondary"
                leftIcon={<Download className="h-4 w-4" />}
                onClick={handleDownload}
              >
                Download
              </Button>
              {onReanalyze && (
                <Button
                  size="sm"
                  variant="secondary"
                  leftIcon={<RotateCcw className="h-4 w-4" />}
                  onClick={onReanalyze}
                >
                  Reanalyze
                </Button>
              )}
            </div>
            <div className="absolute bottom-4 left-4">
              <Badge variant={getComplianceVariant(detection.compliance_status || 'default')} size="lg">
                {detection.compliance_status?.replace('_', ' ').toUpperCase()}
              </Badge>
            </div>
          </div>
        </Card>
      )}


      {/* Person Details */}
      {/* Individual Person Analysis */}
<Card padding="lg">
  <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4 flex items-center gap-2">
    <Users className="h-6 w-6" />
    Individual Analysis ({detection.person_detections?.length || 0} {detection.person_detections?.length === 1 ? 'Person' : 'Persons'})
  </h2>
  
  {!detection.person_detections || detection.person_detections.length === 0 ? (
    <div className="text-center py-8 text-gray-500 dark:text-gray-400">
      <Users className="h-12 w-12 mx-auto mb-3 opacity-50" />
      <p>No person detections found</p>
      <p className="text-sm mt-1">This may be due to processing issues or no persons in the image</p>
    </div>
  ) : (
    <div className="space-y-4">
      {detection.person_detections.map((person) => (
        <div
          key={person.id}
          className={`p-4 rounded-lg border-2 ${
            person.is_compliant
              ? 'border-green-500 dark:border-green-600 bg-green-50 dark:bg-green-900/20'
              : 'border-red-500 dark:border-red-600 bg-red-50 dark:bg-red-900/20'
          }`}
        >
          <div className="flex items-center justify-between mb-3">
            <h3 className="font-semibold text-gray-900 dark:text-white flex items-center gap-2">
              <User className="h-5 w-5" />
              Person #{person.person_id}
            </h3>
            <Badge variant={person.is_compliant ? 'success' : 'danger'}>
              {person.is_compliant ? 'Compliant' : 'Non-Compliant'}
            </Badge>
          </div>


          <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
            {[
              { name: 'Helmet', detected: person.helmet_detected, confidence: person.helmet_confidence },
              { name: 'Safety Vest', detected: person.vest_detected, confidence: person.vest_confidence },
              { name: 'Mask', detected: person.mask_detected, confidence: person.mask_confidence },
            ].map((item) => (
              <div
                key={item.name}
                className={`p-2 rounded text-center text-sm ${
                  item.detected
                    ? 'bg-green-100 dark:bg-green-800/30 text-green-800 dark:text-green-300'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400'
                }`}
              >
                <div className="font-medium">{item.name}</div>
                <div className="text-xs mt-1">
                  {item.detected ? `✓ ${(item.confidence * 100).toFixed(0)}%` : '✗ Not detected'}
                </div>
              </div>
            ))}
          </div>


          {!person.is_compliant && person.missing_ppe && person.missing_ppe.length > 0 && (
            <div className="mt-3 p-3 bg-red-100 dark:bg-red-900/30 rounded border border-red-300 dark:border-red-700">
              <p className="text-sm font-medium text-red-800 dark:text-red-300">
                Missing PPE: {person.missing_ppe.map(item => item.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())).join(', ')}
              </p>
            </div>
          )}
        </div>
      ))}
    </div>
  )}
</Card>



      {/* Violations */}
      {detection.violations && detection.violations.length > 0 && (
        <Card padding="md">
          <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center">
            <AlertTriangle className="h-5 w-5 mr-2 text-red-600" />
            Violations ({detection.violations.length})
          </h3>
          <div className="space-y-3">
            {detection.violations.map((violation) => (
              <div
                key={violation.id}
                className="p-4 border border-red-200 rounded-lg bg-red-50"
              >
                <div className="flex items-start justify-between mb-2">
                  <div>
                    <h4 className="font-medium text-red-900">{violation.violation_type}</h4>
                    <p className="text-sm text-red-700">{violation.description}</p>
                  </div>
                  <Badge variant="danger" size="sm">
                    {violation.severity}
                  </Badge>
                </div>
                <p className="text-sm text-red-600 mt-2">
                  <strong>Recommendation:</strong> {violation.recommendation}
                </p>
                <p className="text-xs text-red-500 mt-1">
                  OSHA Standard: {violation.osha_standard}
                </p>
              </div>
            ))}
          </div>
        </Card>
      )}
    </div>
  );
};


const PPEItem: React.FC<{ name: string; detected: boolean; confidence: number }> = ({
  name,
  detected,
  confidence,
}) => {
  return (
    <div
      className={`p-3 rounded-lg border-2 ${
        detected
          ? 'bg-green-50 border-green-300'
          : 'bg-gray-50 border-gray-300'
      }`}
    >
      <div className="text-2xl mb-1">{getPPEIcon(name)}</div>
      <div className="text-xs font-medium text-gray-900">{getPPELabel(name)}</div>
      {detected && (
        <div className="text-xs text-green-600 mt-1">
          {(confidence * 100).toFixed(0)}%
        </div>
      )}
      {!detected && (
        <div className="text-xs text-red-600 mt-1">
          Not detected
        </div>
      )}
    </div>
  );
};
const exportToPDF = () => {
  // Create print-friendly version
  const printWindow = window.open('', '', 'height=800,width=1000');
  const content = `
    <html>
    <head>
      <title>Safety Report - Detection ${detection.id}</title>
      <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0; }
        .stat-box { border: 2px solid #ddd; padding: 15px; text-align: center; }
        .violation { background: #fee; border-left: 4px solid #f00; padding: 10px; margin: 10px 0; }
        img { max-width: 100%; height: auto; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>SafetySnap - PPE Compliance Report</h1>
        <p>Detection ID: ${detection.id}</p>
        <p>Generated: ${new Date().toLocaleString()}</p>
      </div>
      
      <div class="stats">
        <div class="stat-box">
          <h3>Total Persons</h3>
          <p style="font-size: 24px;">${detection.total_persons_detected}</p>
        </div>
        <div class="stat-box">
          <h3>Compliant</h3>
          <p style="font-size: 24px; color: green;">${detection.compliant_persons}</p>
        </div>
        <div class="stat-box">
          <h3>Non-Compliant</h3>
          <p style="font-size: 24px; color: red;">${detection.non_compliant_persons}</p>
        </div>
      </div>
      
      ${detection.annotated_image ? `
        <h2>Detection Image</h2>
        <img src="${API_BASE_URL}${detection.annotated_image}" alt="Detection Result" />
      ` : ''}
      
      <h2>Violations</h2>
      ${detection.violations && detection.violations.length > 0 ? 
        detection.violations.map(v => `
          <div class="violation">
            <h3>${v.violation_type} - ${v.severity.toUpperCase()}</h3>
            <p><strong>Description:</strong> ${v.description}</p>
            <p><strong>Recommendation:</strong> ${v.recommendation}</p>
            <p><strong>OSHA Standard:</strong> ${v.osha_standard}</p>
          </div>
        `).join('') 
        : '<p>No violations detected</p>'
      }
    </body>
    </html>
  `;
  
  printWindow?.document.write(content);
  printWindow?.document.close();
  printWindow?.print();
  toast.success('Report ready to print/save as PDF!');
};


from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth import authenticate
from rest_framework.authtoken.models import Token
from .serializers import UserSerializer, RegisterSerializer



@api_view(['POST'])
@permission_classes([AllowAny])
def register(request):
    """Register a new user"""
    serializer = RegisterSerializer(data=request.data)
    if serializer.is_valid():
        user = serializer.save()
        token, created = Token.objects.get_or_create(user=user)
        return Response({
            'token': token.key,
            'user': UserSerializer(user).data
        }, status=status.HTTP_201_CREATED)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)



@api_view(['POST'])
@permission_classes([AllowAny])
def login(request):
    """Login user"""
    username = request.data.get('username')
    password = request.data.get('password')
    
    if not username or not password:
        return Response(
            {'error': 'Please provide both username and password'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    user = authenticate(username=username, password=password)
    
    if user:
        token, created = Token.objects.get_or_create(user=user)
        return Response({
            'token': token.key,
            'user': UserSerializer(user).data
        })
    
    return Response(
        {'error': 'Invalid credentials'},
        status=status.HTTP_401_UNAUTHORIZED
    )



@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout(request):
    """Logout user by deleting their token"""
    try:
        request.user.auth_token.delete()
        return Response(
            {'message': 'Successfully logged out'}, 
            status=status.HTTP_200_OK
        )
    except Exception as e:
        return Response(
            {'error': str(e)}, 
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )



@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_user(request):
    """Get current user details"""
    serializer = UserSerializer(request.user)
    return Response(serializer.data)

from rest_framework import serializers
from django.contrib.auth import get_user_model, authenticate
from django.contrib.auth.password_validation import validate_password


User = get_user_model()



class UserSerializer(serializers.ModelSerializer):
    """Serializer for user profile"""
    
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'first_name', 'last_name', 
                 'role', 'phone', 'profile_image', 'site_id', 'created_at']
        read_only_fields = ['id', 'created_at']



class RegisterSerializer(serializers.ModelSerializer):
    """Serializer for user registration"""
    
    password = serializers.CharField(write_only=True, required=True, validators=[validate_password])
    password2 = serializers.CharField(write_only=True, required=True)
    
    class Meta:
        model = User
        fields = ['username', 'email', 'password', 'password2', 'first_name', 
                 'last_name', 'role', 'phone']
    
    def validate(self, attrs):
        if attrs['password'] != attrs['password2']:
            raise serializers.ValidationError({"password": "Password fields didn't match."})
        
        if User.objects.filter(email=attrs['email']).exists():
            raise serializers.ValidationError({"email": "Email already exists."})
        
        return attrs
    
    def create(self, validated_data):
        validated_data.pop('password2')
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data['email'],
            password=validated_data['password'],
            first_name=validated_data.get('first_name', ''),
            last_name=validated_data.get('last_name', ''),
            role=validated_data.get('role', 'worker'),
            phone=validated_data.get('phone', ''),
        )
        return user



class LoginSerializer(serializers.Serializer):
    """Serializer for user login"""
    
    username = serializers.CharField(required=True)
    password = serializers.CharField(required=True, write_only=True)
    
    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')
        
        if username and password:
            user = authenticate(username=username, password=password)
            
            if not user:
                raise serializers.ValidationError('Invalid username or password.')
            
            if not user.is_active:
                raise serializers.ValidationError('User account is disabled.')
            
            attrs['user'] = user
            return attrs
        else:
            raise serializers.ValidationError('Must include "username" and "password".')



class ChangePasswordSerializer(serializers.Serializer):
    """Serializer for password change"""
    
    old_password = serializers.CharField(required=True, write_only=True)
    new_password = serializers.CharField(required=True, write_only=True, validators=[validate_password])
    new_password2 = serializers.CharField(required=True, write_only=True)
    
    def validate(self, attrs):
        if attrs['new_password'] != attrs['new_password2']:
            raise serializers.ValidationError({"new_password": "Password fields didn't match."})
        return attrs


from ultralytics import YOLO
import cv2
import math
import os
from django.conf import settings
import numpy as np


class YOLOPPEDetector:
    """PPE Detection - Vinayakmane47 Style"""
    
    def __init__(self):
        # Use ppe.pt model from Vinayak's repo
        model_path = os.path.join(settings.BASE_DIR, 'ppe.pt')
        
        if not os.path.exists(model_path):
            # Try alternative locations
            alt_paths = [
                os.path.join(settings.BASE_DIR, 'YOLO-Weights', 'ppe.pt'),
                os.path.join(settings.BASE_DIR, 'models', 'ppe_yolo11', 'weights', 'ppe.pt'),
            ]
            
            for alt_path in alt_paths:
                if os.path.exists(alt_path):
                    model_path = alt_path
                    break
            else:
                raise FileNotFoundError(
                    f"ppe.pt model not found. Please download it from:\n"
                    f"https://github.com/Vinayakmane47/PPE_detection_YOLO\n"
                    f"And place it in: {settings.BASE_DIR}/ppe.pt"
                )
        
        self.model = YOLO(model_path)
        
        # Exact class names from Vinayak's repo
        self.classNames = ['Hardhat', 'Mask', 'NO-Hardhat', 'NO-Mask', 'NO-Safety Vest', 
                          'Person', 'Safety Cone', 'Safety Vest', 'machinery', 'vehicle']
        
        print(f"[PPE DETECTOR] Loaded: {model_path}")
        print(f"[PPE DETECTOR] Classes: {self.classNames}")
    
    def detect(self, image_path: str):
        """Detect PPE using Vinayak's method"""
        import time
        start_time = time.time()
        
        print(f"\n{'='*70}")
        print(f"PROCESSING: {os.path.basename(image_path)}")
        print(f"{'='*70}")
        
        # Read image
        img = cv2.imread(image_path)
        if img is None:
            raise ValueError(f"Could not read image: {image_path}")
        
        height, width = img.shape[:2]
        print(f"Image: {width}x{height}px")
        
        # Run YOLO detection (Vinayak's method)
        results = self.model(img, stream=True)
        
        all_detections = []
        ppe_detected = {
            'hardhat': False,
            'mask': False,
            'vest': False,
            'no_hardhat': False,
            'no_mask': False,
            'no_vest': False
        }
        
        for r in results:
            boxes = r.boxes
            for box in boxes:
                # Get bounding box
                x1, y1, x2, y2 = box.xyxy[0]
                x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)
                
                # Confidence
                conf = math.ceil((box.conf[0] * 100)) / 100
                
                # Class
                cls = int(box.cls[0])
                class_name = self.classNames[cls]
                
                print(f"  - {class_name}: {conf:.0%}")
                
                # Determine color (Vinayak's color scheme)
                if class_name == 'Mask' or class_name == 'Hardhat' or class_name == 'Safety Vest':
                    color = (0, 255, 0)  # GREEN
                    
                    if class_name == 'Hardhat':
                        ppe_detected['hardhat'] = True
                    elif class_name == 'Mask':
                        ppe_detected['mask'] = True
                    elif class_name == 'Safety Vest':
                        ppe_detected['vest'] = True
                
                elif class_name == 'NO-Hardhat' or class_name == 'NO-Mask' or class_name == 'NO-Safety Vest':
                    color = (0, 0, 255)  # RED
                    
                    if class_name == 'NO-Hardhat':
                        ppe_detected['no_hardhat'] = True
                    elif class_name == 'NO-Mask':
                        ppe_detected['no_mask'] = True
                    elif class_name == 'NO-Safety Vest':
                        ppe_detected['no_vest'] = True
                
                elif class_name == 'machinery' or class_name == 'vehicle':
                    color = (0, 149, 255)  # ORANGE
                
                else:
                    color = (85, 45, 255)  # PURPLE (Person, Safety Cone)
                
                if conf > 0.5:
                    all_detections.append({
                        'class': class_name,
                        'bbox': [x1, y1, x2, y2],
                        'confidence': conf,
                        'color': color
                    })
        
        print(f"\n[RESULTS] {len(all_detections)} detections")
        
        # Determine compliance
        is_compliant = (
            ppe_detected['hardhat'] and 
            ppe_detected['vest'] and 
            not ppe_detected['no_hardhat'] and 
            not ppe_detected['no_vest']
        )
        
        print(f"[COMPLIANCE] {'COMPLIANT ✓' if is_compliant else 'NON-COMPLIANT ✗'}")
        
        # Create annotated image (Vinayak's style)
        annotated_path = self._create_annotated_image_vinayak_style(
            img, all_detections, image_path
        )
        
        # Build person data
        persons = self._build_person_data(ppe_detected, all_detections, width, height)
        
        processing_time = time.time() - start_time
        print(f"[TIME] {processing_time:.2f}s\n")
        
        return {
            'num_persons': len(persons),
            'persons': persons,
            'avg_confidence': np.mean([d['confidence'] for d in all_detections]) if all_detections else 0,
            'processing_time': round(processing_time, 2),
            'annotated_image_path': annotated_path,
            'is_compliant': is_compliant
        }
    
    def _build_person_data(self, ppe_detected, all_detections, width, height):
        """Build person data from detections - FIXED FOR MULTIPLE PERSONS"""
        if not all_detections:
            return []
        
        # Extract person detections
        person_detections = [d for d in all_detections if d['class'] == 'Person']
        
        if not person_detections:
            # No persons detected - create one worker from all PPE
            all_x = []
            all_y = []
            for d in all_detections:
                all_x.extend([d['bbox'][0], d['bbox'][2]])
                all_y.extend([d['bbox'][1], d['bbox'][3]])
            
            person_bbox = [float(min(all_x)), float(min(all_y)), 
                        float(max(all_x)), float(max(all_y))]
            
            has_helmet = ppe_detected['hardhat'] and not ppe_detected['no_hardhat']
            has_vest = ppe_detected['vest'] and not ppe_detected['no_vest']
            has_mask = ppe_detected['mask'] and not ppe_detected['no_mask']
            
            return [{
                'person_id': 1,
                'bbox': person_bbox,
                'confidence': 0.85,
                'ppe': {
                    'helmet': {'detected': has_helmet, 'confidence': 0.85 if has_helmet else 0.0},
                    'safety_vest': {'detected': has_vest, 'confidence': 0.85 if has_vest else 0.0},
                    'safety_boots': {'detected': True, 'confidence': 0.70},
                    'gloves': {'detected': False, 'confidence': 0.0},
                    'safety_glasses': {'detected': False, 'confidence': 0.0},
                    'face_mask': {'detected': has_mask, 'confidence': 0.80 if has_mask else 0.0},
                    'harness': {'detected': False, 'confidence': 0.0}
                }
            }]
        
        # Multiple persons detected - analyze each one
        # Multiple persons detected - analyze each one
        persons = []
        ppe_items = [d for d in all_detections if d['class'] != 'Person']


        for idx, person_det in enumerate(person_detections):
            px1, py1, px2, py2 = person_det['bbox']
            person_conf = person_det['confidence']
            
            print(f"\n  Analyzing Person #{idx+1} at bbox: ({px1:.0f}, {py1:.0f}, {px2:.0f}, {py2:.0f})")
            
            # IMPROVED: Use person's actual bbox + small margin
            # Head area (top 30% of person)
            person_height = py2 - py1
            head_margin = 20
            head_box = [px1 - head_margin, py1 - head_margin, 
                        px2 + head_margin, py1 + (person_height * 0.3) + head_margin]
            
            # Torso area (middle 40% of person)
            torso_margin = 30
            torso_box = [px1 - torso_margin, py1 + (person_height * 0.2), 
                        px2 + torso_margin, py1 + (person_height * 0.6)]
            
            # Full body with small margin
            body_margin = 25
            body_box = [px1 - body_margin, py1 - body_margin, 
                        px2 + body_margin, py2 + body_margin]
            
            # Find PPE near this person with IMPROVED LOGIC
            person_ppe = {
                'has_helmet': False,
                'has_vest': False,
                'has_mask': False,
                'no_helmet': False,
                'no_vest': False,
                'no_mask': False
            }
            
            # Track confidence scores for tie-breaking
            helmet_conf = 0
            vest_conf = 0
            
            for ppe in ppe_items:
                ppe_class = ppe['class']
                ppe_bbox = ppe['bbox']
                ppe_conf = ppe['confidence']
                
                # Calculate PPE center point
                ppe_center_x = (ppe_bbox[0] + ppe_bbox[2]) / 2
                ppe_center_y = (ppe_bbox[1] + ppe_bbox[3]) / 2
                
                # Check helmet in HEAD area only
                if ppe_class in ['Hardhat', 'NO-Hardhat']:
                    if self._point_in_box(ppe_center_x, ppe_center_y, head_box):
                        if ppe_conf > helmet_conf:  # Take highest confidence
                            print(f"    Found in HEAD: {ppe_class} ({ppe_conf:.2f})")
                            if ppe_class == 'Hardhat':
                                person_ppe['has_helmet'] = True
                                person_ppe['no_helmet'] = False
                            else:
                                person_ppe['no_helmet'] = True
                                person_ppe['has_helmet'] = False
                            helmet_conf = ppe_conf
                
                # Check vest in TORSO area only
                elif ppe_class in ['Safety Vest', 'NO-Safety Vest']:
                    if self._point_in_box(ppe_center_x, ppe_center_y, torso_box):
                        if ppe_conf > vest_conf:  # Take highest confidence
                            print(f"    Found in TORSO: {ppe_class} ({ppe_conf:.2f})")
                            if ppe_class == 'Safety Vest':
                                person_ppe['has_vest'] = True
                                person_ppe['no_vest'] = False
                            else:
                                person_ppe['no_vest'] = True
                                person_ppe['has_vest'] = False
                            vest_conf = ppe_conf
                
                # Check mask in HEAD area
                elif ppe_class in ['Mask', 'NO-Mask']:
                    if self._point_in_box(ppe_center_x, ppe_center_y, head_box):
                        print(f"    Found in HEAD: {ppe_class}")
                        if ppe_class == 'Mask':
                            person_ppe['has_mask'] = True
                        else:
                            person_ppe['no_mask'] = True
            
            # Determine final status
            has_helmet = person_ppe['has_helmet']
            has_vest = person_ppe['has_vest']
            has_mask = person_ppe['has_mask']
            
            print(f"    Final: Helmet={has_helmet}, Vest={has_vest}, Mask={has_mask}")
            
            persons.append({
                'person_id': idx + 1,
                'bbox': [float(px1), float(py1), float(px2), float(py2)],
                'confidence': round(person_conf, 2),
                'ppe': {
                    'helmet': {'detected': has_helmet, 'confidence': helmet_conf if has_helmet else 0.0},
                    'safety_vest': {'detected': has_vest, 'confidence': vest_conf if has_vest else 0.0},
                    'safety_boots': {'detected': True, 'confidence': 0.70},
                    'gloves': {'detected': False, 'confidence': 0.0},
                    'safety_glasses': {'detected': False, 'confidence': 0.0},
                    'face_mask': {'detected': has_mask, 'confidence': 0.80 if has_mask else 0.0},
                    'harness': {'detected': False, 'confidence': 0.0}
                }
            })


        return persons




    def _boxes_overlap(self, box1, box2):
        """Check if two bounding boxes overlap"""
        x1_min, y1_min, x1_max, y1_max = box1
        x2_min, y2_min, x2_max, y2_max = box2
        
        # Check if boxes overlap
        return not (x1_max < x2_min or x2_max < x1_min or 
                    y1_max < y2_min or y2_max < y1_min)


    def _point_in_box(self, px, py, box):
        """Check if a point (x,y) is inside a box [x1, y1, x2, y2]"""
        x1, y1, x2, y2 = box
        return x1 <= px <= x2 and y1 <= py <= y2
    
    def _create_annotated_image_vinayak_style(self, img, detections, original_path):
        """Create annotated image matching Vinayak's repo style"""
        annotated = img.copy()
        
        for detection in detections:
            class_name = detection['class']
            x1, y1, x2, y2 = detection['bbox']
            conf = detection['confidence']
            color = detection['color']
            
            # Create label
            label = f'{class_name} {conf}'
            
            # Get text size
            t_size = cv2.getTextSize(label, 0, fontScale=1, thickness=2)[0]
            c2 = x1 + t_size[0], y1 - t_size[1] - 3
            
            # Draw rectangle (bounding box)
            cv2.rectangle(annotated, (x1, y1), (x2, y2), color, 3)
            
            # Draw filled rectangle for text background
            cv2.rectangle(annotated, (x1, y1), c2, color, -1, cv2.LINE_AA)
            
            # Draw text
            cv2.putText(annotated, label, (x1, y1 - 2), 0, 1, 
                       [255, 255, 255], thickness=1, lineType=cv2.LINE_AA)
        
        # Save annotated image
        results_dir = os.path.join(settings.MEDIA_ROOT, 'results')
        os.makedirs(results_dir, exist_ok=True)
        
        import time
        filename = f"annotated_{os.path.splitext(os.path.basename(original_path))[0]}_{int(time.time())}.jpg"
        annotated_path = os.path.join(results_dir, filename)
        
        cv2.imwrite(annotated_path, annotated)
        print(f"[SAVED] {annotated_path}")
        
        return annotated_path



def get_detector():
    return YOLOPPEDetector()

from rest_framework import viewsets, status
from rest_framework.decorators import action, api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.parsers import MultiPartParser, FormParser, JSONParser
from django.core.files.base import ContentFile
from django.db import transaction
from django.utils import timezone
from django.conf import settings
import os
from datetime import timedelta


from .models import Detection, PersonDetection, Violation, PPEPolicy
from .serializers import (
    DetectionSerializer, DetectionCreateSerializer,
    PersonDetectionSerializer, ViolationSerializer, PPEPolicySerializer,
    NotificationSerializer
)
from .yolo_service import get_detector  # Use real YOLO model


from users.models import Site



class PPEPolicyViewSet(viewsets.ModelViewSet):
    """ViewSet for PPE Policy operations"""
    serializer_class = PPEPolicySerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        """Get active PPE policies"""
        # FIXED: Return PPEPolicy objects, not Detection objects!
        queryset = PPEPolicy.objects.filter(is_active=True)
        
        site_id = self.request.query_params.get('site', None)
        if site_id:
            queryset = queryset.filter(site_id=site_id)
        
        return queryset.order_by('name')


from django.http import StreamingHttpResponse
import cv2


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def process_video(request):
    """Process uploaded video file"""
    video_file = request.FILES.get('video')
    
    if not video_file:
        return Response({'error': 'No video file provided'}, status=400)
    
    # Save video temporarily
    import tempfile
    with tempfile.NamedTemporaryFile(delete=False, suffix='.mp4') as tmp:
        for chunk in video_file.chunks():
            tmp.write(chunk)
        video_path = tmp.name
    
    # Process video
    monitor = VideoSafetyMonitor()
    cap = cv2.VideoCapture(video_path)
    
    results = []
    frame_count = 0
    
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        
        # Process every 5th frame for speed
        if frame_count % 5 == 0:
            result = monitor.process_frame(frame)
            results.append({
                'frame': frame_count,
                'stats': result['frame_stats']
            })
        
        frame_count += 1
    
    cap.release()
    os.unlink(video_path)
    
    return Response({
        'total_frames': frame_count,
        'processed_frames': len(results),
        'summary': {
            'avg_persons': sum(r['stats']['total'] for r in results) / len(results) if results else 0,
            'avg_violations': sum(r['stats']['violations'] for r in results) / len(results) if results else 0
        },
        'frame_results': results
    })



@api_view(['GET'])
@permission_classes([IsAuthenticated])
def webcam_stream(request):
    """Stream webcam with PPE detection"""
    def generate():
        monitor = VideoSafetyMonitor()
        cap = cv2.VideoCapture(0)  # Webcam
        
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            
            # Process frame
            result = monitor.process_frame(frame)
            
            # Annotate frame
            annotated = frame.copy()
            for person in result['persons']:
                x1, y1, x2, y2 = [int(c) for c in person['bbox']]
                
                is_compliant = monitor._is_compliant(person)
                color = (0, 255, 0) if is_compliant else (0, 0, 255)
                
                cv2.rectangle(annotated, (x1, y1), (x2, y2), color, 2)
                cv2.putText(annotated, f"ID: {person['track_id']}", (x1, y1-10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
            
            # Encode frame
            _, buffer = cv2.imencode('.jpg', annotated)
            frame_bytes = buffer.tobytes()
            
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
        
        cap.release()
    
    return StreamingHttpResponse(generate(), content_type='multipart/x-mixed-replace; boundary=frame')


class DetectionViewSet(viewsets.ModelViewSet):
    """ViewSet for Detection operations"""
    serializer_class = DetectionSerializer
    permission_classes = [IsAuthenticated]
    parser_classes = [MultiPartParser, FormParser, JSONParser]
    pagination_class = None
    
    def get_queryset(self):
        """Get detections for current user only"""
        queryset = Detection.objects.filter(user=self.request.user).select_related(
            'site', 'policy', 'user'
        ).prefetch_related(
            'person_detections',
            'violations'
        ).order_by('-created_at')
        
        # Apply filters if provided
        site = self.request.query_params.get('site', None)
        status_param = self.request.query_params.get('status', None)
        compliance_status = self.request.query_params.get('compliance_status', None)
        
        if site:
            queryset = queryset.filter(site_id=site)
        if status_param:
            queryset = queryset.filter(status=status_param)
        if compliance_status:
            queryset = queryset.filter(compliance_status=compliance_status)
        
        return queryset
    
    def get_serializer_class(self):
        """Return appropriate serializer based on action"""
        if self.action == 'create':
            return DetectionCreateSerializer
        return DetectionSerializer
    
    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """Get detection statistics for current user only"""
        queryset = Detection.objects.filter(user=request.user)
        
        total_detections = queryset.count()
        
        if total_detections == 0:
            return Response({
                'total_detections': 0,
                'total_persons_scanned': 0,
                'total_violations': 0,
                'compliant': 0,
                'partial_compliant': 0,
                'non_compliant': 0,
                'compliance_rate': 0,
            })
        
        total_persons = sum(d.total_persons_detected for d in queryset)
        total_violations = Violation.objects.filter(detection__user=request.user).count()
        
        compliant = queryset.filter(compliance_status='compliant').count()
        partial = queryset.filter(compliance_status='partial').count()
        non_compliant = queryset.filter(compliance_status='non_compliant').count()
        
        return Response({
            'total_detections': total_detections,
            'total_persons_scanned': total_persons,
            'total_violations': total_violations,
            'compliant': compliant,
            'partial_compliant': partial,
            'non_compliant': non_compliant,
            'compliance_rate': (compliant / total_detections * 100) if total_detections > 0 else 0,
        })
    
    @transaction.atomic
    def create(self, request, *args, **kwargs):
        """Create a new detection"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        image = serializer.validated_data.get('original_image')
        policy_id = serializer.validated_data.get('policy')
        
        policy = None
        if policy_id:
            try:
                if isinstance(policy_id, PPEPolicy):
                    policy = policy_id
                else:
                    policy = PPEPolicy.objects.get(id=policy_id, is_active=True)
            except PPEPolicy.DoesNotExist:
                pass
        
        detection = serializer.save(
            user=request.user,
            status='processing',
            policy=policy
        )
        
        try:
            detector = get_detector()
            print(f"[VIEWS] Using detector: {type(detector).__name__}")
            
            image_path = detection.original_image.path
            print(f"[VIEWS] Processing image: {image_path}")
            
            results = detector.detect(image_path)
            print(f"[VIEWS] Detection results: {results.get('num_persons')} persons found")
            
            # Save annotated image
            if results.get('annotated_image_path'):
                annotated_path = results['annotated_image_path']
                if os.path.exists(annotated_path):
                    with open(annotated_path, 'rb') as f:
                        detection.annotated_image.save(
                            os.path.basename(annotated_path),
                            ContentFile(f.read()),
                            save=False
                        )
                    try:
                        os.remove(annotated_path)
                    except:
                        pass
            
            detection.total_persons_detected = results.get('num_persons', 0)
            detection.confidence_score = results.get('avg_confidence', 0)
            detection.processing_time = results.get('processing_time', 0)
            detection.status = 'completed'
            
            compliant_count = 0
            non_compliant_count = 0
            
            for idx, person in enumerate(results.get('persons', [])):
                bbox = person.get('bbox', [0, 0, 0, 0])
                ppe = person.get('ppe', {})
                
                missing_items = []
                is_compliant = True
                
                checks = {
                    'helmet': policy.helmet_required if policy else True,
                    'safety_vest': policy.vest_required if policy else True,
                    'safety_boots': policy.boots_required if policy else False,
                    'gloves': policy.gloves_required if policy else False,
                    'safety_glasses': policy.glasses_required if policy else False,
                    'face_mask': policy.mask_required if policy else False,
                    'harness': policy.harness_required if policy else False,
                }
                
                for ppe_item, required in checks.items():
                    if required and not ppe.get(ppe_item, {}).get('detected', False):
                        missing_items.append(ppe_item)
                        is_compliant = False
                
                if is_compliant:
                    compliant_count += 1
                else:
                    non_compliant_count += 1
                
                person_detection = PersonDetection.objects.create(
                    detection=detection,
                    person_id=idx + 1,
                    bbox_x1=float(bbox[0]),
                    bbox_y1=float(bbox[1]),
                    bbox_x2=float(bbox[2]),
                    bbox_y2=float(bbox[3]),
                    confidence=float(person.get('confidence', 0)),
                    helmet_detected=ppe.get('helmet', {}).get('detected', False),
                    helmet_confidence=float(ppe.get('helmet', {}).get('confidence', 0)),
                    vest_detected=ppe.get('safety_vest', {}).get('detected', False),
                    vest_confidence=float(ppe.get('safety_vest', {}).get('confidence', 0)),
                    boots_detected=ppe.get('safety_boots', {}).get('detected', False),
                    boots_confidence=float(ppe.get('safety_boots', {}).get('confidence', 0)),
                    gloves_detected=ppe.get('gloves', {}).get('detected', False),
                    gloves_confidence=float(ppe.get('gloves', {}).get('confidence', 0)),
                    glasses_detected=ppe.get('safety_glasses', {}).get('detected', False),
                    glasses_confidence=float(ppe.get('safety_glasses', {}).get('confidence', 0)),
                    mask_detected=ppe.get('face_mask', {}).get('detected', False),
                    mask_confidence=float(ppe.get('face_mask', {}).get('confidence', 0)),
                    harness_detected=ppe.get('harness', {}).get('detected', False),
                    harness_confidence=float(ppe.get('harness', {}).get('confidence', 0)),
                    is_compliant=is_compliant,
                    missing_ppe=missing_items
                )
                
                if not is_compliant and missing_items:
                    violation_desc = f"Person {idx + 1} is missing: {', '.join([item.replace('_', ' ').title() for item in missing_items])}"
                    
                    severity = 'medium'
                    if 'helmet' in missing_items or 'harness' in missing_items:
                        severity = 'critical'
                    elif 'safety_vest' in missing_items:
                        severity = 'high'
                    
                    osha_standard = "29 CFR 1910.132"
                    if 'helmet' in missing_items:
                        osha_standard = "29 CFR 1910.135"
                    elif 'harness' in missing_items:
                        osha_standard = "29 CFR 1910.140"
                    
                    Violation.objects.create(
                        detection=detection,
                        person_detection=person_detection,
                        violation_type=f"Missing PPE: {', '.join([item.replace('_', ' ').title() for item in missing_items])}",
                        severity=severity,
                        description=violation_desc,
                        recommendation=f"Worker must wear {', '.join([item.replace('_', ' ') for item in missing_items])} before entering work area",
                        osha_standard=osha_standard,
                        status='open'
                    )
            
            detection.compliant_persons = compliant_count
            detection.non_compliant_persons = non_compliant_count
            
            if detection.total_persons_detected == 0:
                detection.compliance_status = 'compliant'
            elif compliant_count == detection.total_persons_detected:
                detection.compliance_status = 'compliant'
            elif non_compliant_count == detection.total_persons_detected:
                detection.compliance_status = 'non_compliant'
            else:
                detection.compliance_status = 'partial'
            
            detection.save()
            
            output_serializer = DetectionSerializer(detection)
            return Response(output_serializer.data, status=status.HTTP_201_CREATED)
            
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            print(f"Detection error: {error_trace}")
            
            detection.status = 'failed'
            detection.notes = str(e)
            detection.save()
            
            return Response(
                {'error': f'Detection failed: {str(e)}'},
                status=status.HTTP_400_BAD_REQUEST
            )



class ViolationViewSet(viewsets.ReadOnlyModelViewSet):
    """ViewSet for Violation operations"""
    serializer_class = ViolationSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        """Get violations for current user's detections only"""
        queryset = Violation.objects.filter(
            detection__user=self.request.user
        ).select_related('detection', 'person_detection').order_by('-created_at')
        
        status_param = self.request.query_params.get('status', None)
        severity = self.request.query_params.get('severity', None)
        
        if status_param:
            queryset = queryset.filter(status=status_param)
        if severity:
            queryset = queryset.filter(severity=severity)
        
        return queryset
    
    @action(detail=True, methods=['post'])
    def acknowledge(self, request, pk=None):
        """Acknowledge a violation"""
        violation = self.get_object()
        violation.status = 'acknowledged'
        violation.acknowledged_by = request.user
        violation.acknowledged_at = timezone.now()
        violation.save()
        
        serializer = self.get_serializer(violation)
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def resolve(self, request, pk=None):
        """Resolve a violation"""
        violation = self.get_object()
        violation.status = 'resolved'
        violation.resolved_by = request.user
        violation.resolved_at = timezone.now()
        violation.save()
        
        serializer = self.get_serializer(violation)
        return Response(serializer.data)



@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_notifications(request):
    """Get real-time notifications from recent detections and violations"""
    twenty_four_hours_ago = timezone.now() - timedelta(hours=24)
    recent_detections = Detection.objects.filter(
        user=request.user,
        created_at__gte=twenty_four_hours_ago
    ).order_by('-created_at')[:10]
    
    recent_violations = Violation.objects.filter(
        detection__user=request.user,
        created_at__gte=twenty_four_hours_ago,
        status__in=['open', 'acknowledged']
    ).order_by('-created_at')[:10]
    
    notifications = []
    
    for violation in recent_violations:
        notif_type = 'danger' if violation.severity in ['critical', 'high'] else 'warning'
        notifications.append({
            'id': f'violation_{violation.id}',
            'type': notif_type,
            'title': f'{violation.severity.upper()} - {violation.violation_type}',
            'message': violation.description,
            'timestamp': violation.created_at,
            'read': violation.status == 'acknowledged',
            'detection_id': str(violation.detection.id),
            'violation_id': violation.id,
        })
    
    for detection in recent_detections:
        if detection.status == 'completed':
            if detection.compliance_status == 'compliant':
                notif_type = 'success'
                title = '✓ Full Compliance'
                message = f'All {detection.total_persons_detected} persons are compliant'
            elif detection.compliance_status == 'non_compliant':
                notif_type = 'danger'
                title = '✗ Non-Compliant'
                message = f'{detection.non_compliant_persons} out of {detection.total_persons_detected} persons have violations'
            else:
                notif_type = 'warning'
                title = '⚠ Partial Compliance'
                message = f'{detection.compliant_persons} compliant, {detection.non_compliant_persons} non-compliant'
            
            notifications.append({
                'id': f'detection_{detection.id}',
                'type': notif_type,
                'title': title,
                'message': message,
                'timestamp': detection.created_at,
                'read': False,
                'detection_id': str(detection.id),
                'violation_id': None,
            })
        elif detection.status == 'failed':
            notifications.append({
                'id': f'detection_{detection.id}',
                'type': 'danger',
                'title': 'Detection Failed',
                'message': f'Image processing failed: {detection.notes}',
                'timestamp': detection.created_at,
                'read': False,
                'detection_id': str(detection.id),
                'violation_id': None,
            })
    
    notifications.sort(key=lambda x: x['timestamp'], reverse=True)
    notifications = notifications[:20]
    
    serializer = NotificationSerializer(notifications, many=True)
    return Response(serializer.data)



@api_view(['POST'])
@permission_classes([IsAuthenticated])
def mark_notification_read(request, notification_id):
    """Mark a notification as read"""
    try:
        if notification_id.startswith('violation_'):
            violation_id = int(notification_id.split('_')[1])
            try:
                violation = Violation.objects.get(id=violation_id, detection__user=request.user)
                if violation.status == 'open':
                    violation.status = 'acknowledged'
                    violation.acknowledged_by = request.user
                    violation.acknowledged_at = timezone.now()
                    violation.save()
                return Response({'status': 'success', 'message': 'Notification marked as read'})
            except Violation.DoesNotExist:
                return Response({'error': 'Violation not found'}, status=404)
        
        return Response({'status': 'success', 'message': 'Notification marked as read'})
    
    except Exception as e:
        return Response({'error': str(e)}, status=400)



@api_view(['POST'])
@permission_classes([IsAuthenticated])
def mark_all_notifications_read(request):
    """Mark all notifications as read"""
    Violation.objects.filter(
        detection__user=request.user,
        status='open'
    ).update(
        status='acknowledged',
        acknowledged_by=request.user,
        acknowledged_at=timezone.now()
    )
    return Response({'status': 'success'})



@api_view(['GET'])
@permission_classes([IsAuthenticated])
def debug_detections(request):
    """Debug endpoint to check detections"""
    all_detections = Detection.objects.all()
    user_detections = Detection.objects.filter(user=request.user)
    
    return Response({
        'total_detections': all_detections.count(),
        'your_detections': user_detections.count(),
        'your_username': request.user.username,
        'recent_detections': [
            {
                'id': str(d.id),
                'user': d.user.username,
                'status': d.status,
                'persons': d.total_persons_detected,
            }
            for d in user_detections.order_by('-created_at')[:5]
        ]
    })


from rest_framework import serializers
from .models import Detection, PersonDetection, Violation, PPEPolicy
from users.models import Site



class PPEPolicySerializer(serializers.ModelSerializer):
    """Serializer for PPE Policy"""
    required_items = serializers.SerializerMethodField()
    
    class Meta:
        model = PPEPolicy
        fields = [
            'id', 'name', 'description', 'zone_type', 'risk_level',
            'helmet_required', 'vest_required', 'boots_required',
            'gloves_required', 'glasses_required', 'mask_required',
            'harness_required', 'is_active', 'required_items'
        ]
    
    def get_required_items(self, obj):
        """Get list of required PPE items"""
        items = []
        if obj.helmet_required:
            items.append('helmet')
        if obj.vest_required:
            items.append('safety_vest')
        if obj.boots_required:
            items.append('safety_boots')
        if obj.gloves_required:
            items.append('gloves')
        if obj.glasses_required:
            items.append('safety_glasses')
        if obj.mask_required:
            items.append('face_mask')
        if obj.harness_required:
            items.append('harness')
        return items



class PersonDetectionSerializer(serializers.ModelSerializer):
    """Serializer for PersonDetection"""
    
    class Meta:
        model = PersonDetection
        fields = [
            'id', 'person_id', 'bbox_x1', 'bbox_y1', 'bbox_x2', 'bbox_y2',
            'confidence', 'is_compliant', 'missing_ppe',
            'helmet_detected', 'helmet_confidence',
            'vest_detected', 'vest_confidence',
            'boots_detected', 'boots_confidence',
            'gloves_detected', 'gloves_confidence',
            'glasses_detected', 'glasses_confidence',
            'mask_detected', 'mask_confidence',
            'harness_detected', 'harness_confidence',
        ]



class ViolationSerializer(serializers.ModelSerializer):
    """Serializer for Violation"""
    
    class Meta:
        model = Violation
        fields = [
            'id', 'violation_type', 'severity', 'status',
            'description', 'recommendation', 'osha_standard',
            'created_at', 'acknowledged_at', 'resolved_at',
        ]



class DetectionSerializer(serializers.ModelSerializer):
    """Full serializer for Detection with nested data"""
    person_detections = PersonDetectionSerializer(many=True, read_only=True)
    violations = ViolationSerializer(many=True, read_only=True)
    site_name = serializers.CharField(source='site.name', read_only=True, allow_null=True)
    policy_name = serializers.CharField(source='policy.name', read_only=True, allow_null=True)
    
    class Meta:
        model = Detection
        fields = [
            'id', 'user', 'site', 'site_name', 'policy', 'policy_name',
            'original_image', 'annotated_image', 'status', 'compliance_status',
            'total_persons_detected', 'compliant_persons', 'non_compliant_persons',
            'confidence_score', 'processing_time', 'notes',
            'location_lat', 'location_lng', 'created_at', 'updated_at',
            'person_detections', 'violations'
        ]
        read_only_fields = [
            'id', 'user', 'status', 'compliance_status', 'annotated_image',
            'total_persons_detected', 'compliant_persons', 'non_compliant_persons',
            'confidence_score', 'processing_time', 'created_at', 'updated_at',
            'person_detections', 'violations'
        ]




class DetectionCreateSerializer(serializers.ModelSerializer):
    """Serializer for creating detections"""
    
    class Meta:
        model = Detection
        fields = ['original_image', 'site', 'policy', 'notes', 'location_lat', 'location_lng']
    
    def validate(self, data):
        # If no policy provided, use default policy
        if not data.get('policy'):
            try:
                default_policy = PPEPolicy.objects.filter(
                    name__icontains='default',
                    is_active=True
                ).first()
                
                if default_policy:
                    data['policy'] = default_policy
            except PPEPolicy.DoesNotExist:
                pass  # No default policy, will handle in view
        
        return data




class SiteSerializer(serializers.ModelSerializer):
    """Serializer for Site"""
    
    class Meta:
        model = Site
        fields = ['id', 'name', 'location', 'description', 'is_active']



from datetime import datetime, timedelta


class NotificationSerializer(serializers.Serializer):
    """Serializer for notifications"""
    id = serializers.CharField()
    type = serializers.CharField()
    title = serializers.CharField()
    message = serializers.CharField()
    timestamp = serializers.DateTimeField()
    read = serializers.BooleanField()
    detection_id = serializers.UUIDField(required=False, allow_null=True)
    violation_id = serializers.IntegerField(required=False, allow_null=True)

see the issue i am not able to see the uploaded image and the image after analyzing 


Upload.tsx:42  POST http://localhost:8000/api/ppe/detections/ 400 (Bad Request)
Upload.tsx:56 Upload failed: 
AxiosError {message: 'Request failed with status code 400', name: 'AxiosError', code: 'ERR_BAD_REQUEST', config: {…}, request: XMLHttpRequest, …}
Upload.tsx:57 Error response: 
{error: "Detection failed: 'YOLOPPEDetector' object has no attribute '_point_in_box'"}
﻿



